# 백준 8394번 악수
https://www.acmicpc.net/problem/8394
---

### 문제 해결 날짜
- 2021.01.18
---

### 접근 방식
- 각 케이스를 두 경우로 분리
    1. 점으로 끝나는 경우(마지막 사람이 악수하지 않는 경우)
    2. 선으로 끝나는 경우(마지막 사람이 악수하는 경우)
- 변수 d, l에 각각 점으로 끝나는 경우의 수와 선으로 끝나는 경우의 수를 저장
- 위의 분석을 기반으로 점화식을 세우면 아래와 같다. (```d[i]```는 n=i일 때 d, l도 마찬가지)
    1. 점으로 끝나면 n=i-1일 때 오른쪽 끝점에서 선을 잇는 경우와 아닌 경우로 나뉘므로```d[i] = d[i-1] + l[i-1]```
    2. 선으로 끝나면 ```l[i]에서 오른쪽 끝에 점을 하나 추가하는 경우밖에 없으므로 l[i] = d[i]```
- 따라서 i=1, d, l = 1, 0에서 시작해 n가 n이 될 때까지 d, l = d+l, d을 반복한다.(단, 수가 매우 커질 수 있으므로 d, l을 초기화할 때 10으로 나눈 나머지를 저장한다.)
---

### 문제를 풀고 느낀점
- n이 매우 커지거나 수가 크면 메모리 사용량이 늘기 때문에 메모리 초과가 발생할 수 있다는 것을 알았다.(메모리 초과를 이 문제로 처음 겪어봤다.)
- 또한 수가 커질수록 수들을 계산하는 데 걸리는 시간도 많이 소요되어 처음에는 답을 출력할 때만 마지막 자리수만 추려 출력했지만, 시간초과를 겪고 나서 시간을 단축하기 위해 d, l단계에서부터 10으로 나눈 나머지를 사용했다.(어차피 10으로 나눈 나머지를 사용해도 일의 자리는 사용하지 않을 때와 같으므로)

### 소스코드
- 메모리 : 30860KB
- 시간 : 2100ms
```Python
import sys
n = int(sys.stdin.readline())
d, l = 1, 0 #d, l은 각각 n=i일때 점으로 끝나는 경우의 수, 선으로 끝나는 경우의 수
i=1
while i<n:
    d, l = (d+l)%10, d%10
    i+=1
print((d+l)%10)
```