# 백준 17291번 새끼치기
https://www.acmicpc.net/problem/17291
---

### 문제 해결 날짜
- 2021.01.20
---
## 풀이 1
### 접근 방식
- DP 점화식: ```P[i]는 i년에 탄생한 벌레의 수```
- i의 홀짝에 따라 경우가 달라짐(홀수년에 탄생한 벌레는 3번, 짝수년에 탄생한 벌레는 4번 분열하고 죽기 때문)
    + i가 홀수인 경우 i-3년부터 i-1년에 탄생한 벌레들이 분열해 ```P[i]가 됨```
    + i가 짝수인 경우 i-4년부터 i-1년에 탄생한 벌레들이 분열해 ```P[i]가 됨```
- n년 말에 생존한 벌레의 수는 두가지로 나뉨
    + n이 3이하이면 분열하고 죽는 벌레가 없으므로 ```n년 말에 생존한 벌레의 수는 P[1] ... P[n] 까지의 합```
    + n이 3초과이면
        * n이 홀수이면 n년 말에 생존한 벌레의 수는 ```P[n-3]부터 P[n]까지의 합```
        * n이 짝수이면 n년 말에 생존한 벌레의 수는 ```P[n-2]부터 P[n]까지의 합```
---

### 소스코드
- 메모리 : 30864KB
- 시간 : 68ms
```Python
import sys
n = int(sys.stdin.readline())
P = [0]*21 #P[i]는 i년에 탄생한 벌레의 수
P[1] = 1
P[2] = 1
P[3] = 2
for i in range(4,n+1):
    born = 0
    if i%2:
        for j in range(i-3,i):
            born += P[j]
    else:
        for j in range(i-4,i):
            born += P[j]
    P[i] = born
survived = 0 #생존 개체의 수
if n <= 3:
    for i in range(1,n+1):
        survived += P[i]
else:
    if n%2:
        for i in range(n-3,n+1):
            survived += P[i]
    else:
        for i in range(n-2,n+1):
            survived += P[i]
print(survived)
```

## 풀이 2
### 접근 방식
- DP점화식: ```P[i]는 i년 말에 생존한 벌레의 수```
- i의 홀짝에 따라 ```P[i]가 결정됨```
    + i가 홀수이면 ```P[i] = P[i-1]*2```
    + i가 짝수이면 ```P[i] = P[i-1]*2 - P[i-4] - P[i-5]```(분열을 모두 한 벌레가 죽으므로)
- ```P[4]를 구할 때 논리적 오류가 발생할 수 있으나, 그것을 막기 위해서 P[0]=1로 초기화 했고, i=4일 때 P[i-5] = P[-1]이나, P[-1] = P[20] = 0 이기 때문에 논리적 오류가 발생하지 않는다.```
---
### 오답노트
- 메모리를 줄이려고 P의 크기를 min(6,n+1)로도 해보았으나 풀이 1과 메모리가 동일한 것으로 보아 백준 채점상 모든 테스트케이스에서의 메모리 사용량의 합이 메모리라고 추정

---

### 소스코드
- 메모리 : 30864KB
- 시간 : 68ms
```Python
import sys
n = int(sys.stdin.readline())
P = [0]*21 #P[i]는 i년 말의 생존개체 수
P[0]=1
P[1]=1
for i in range(2,n+1):
    if i%2:
        P[i] = P[i-1]*2
    else:
        P[i] = P[i-1]*2 - P[i-4] - P[i-5]
print(P[n])
```